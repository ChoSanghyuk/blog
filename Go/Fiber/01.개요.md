# 01. Fiber 개요



## 소개

Fiber는 Node.js 생태계의 Express 프레임워크로 부터 영감을 받아 나온 Go의 웹 어플리케이션 프레임워크로, Go에게 가장 빠른 http 엔진인 Fasthttp을 기반으로 한다. Fiber는 zero memory allocation과 높은 performance를 제공함으로 개발자가 빠른 개발에 집중할 수 있도록 고안되었다.

:bulb: zero memory allocation : `go test -bench` 실행 시 나오는 `allocs/op`(operation 당 메모리 할당 값)이 0이라는 것으로, 해당 값은 동적 할당(heap 영역에서의 할당)과 관련되어 있다. 따라서 zero allocation이란, library 자체에서는 heap 영역에서의 동적 할당을 하지 않음을 의미한다.

https://medium.com/@muroon/the-reason-why-zap-and-zerolog-make-it-zero-allocation-3ee8f69f660



Fiber의 장점과 단점으로는 다음과 같이 있다.

| 장점                                                         | 단점                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 높은 성능<br /> - Express나 다른 Go 프레임워크에 비해 빠른 속도를 가짐<br /> - zero allocation과 뛰어난 라우팅 속도 | 작은 생태계<br /> - Express나 Gin과 같은 프레임워크에 비해 작은 미들웨어 생태계를 가짐<br /> - ORM과 DB 지원에 있어서 다소 부족함 |
| 간결한 설계<br /> - 필요한 기능만을 제공하여 불필요한 복잡성을 배제<br /> - web 개발에 있어서 최소한의 boilerplate code만 가짐 | 작은 커뮤니티 규모<br /> - 비교적 신생 프레임워크이기에, 상대적으로 작은 커뮤니티와 적은 관련 문서를 가지고 있음 |
| 높은 확장성<br /> - 라우팅과 플러그인을 위한 다양한 미들웨어 지원<br /> - 분산 환경에서의 어플리케이션 확장 지원 | 낮은 유연성<br /> - Fiber가 제공하는 기능과 구조에 따라 개발 필요<br /> - 프로젝트의 초기 단계에서  많은 설계 결정 필요 |

:bulb: boilerplate code : 특정 문제를 해결하기 위해 반복적으로 작성되지만 가치가 낮은 코드

https://www.monocubed.com/blog/golang-web-frameworks/

https://gofiber.io



## 시작하기



### 설치

- 사전 준비

  - version 1.21 이상의 go 설치

- Fiber 설치

  - 프로젝트의 root 폴더의 위치에서 terminal에 다음 명령어를 실행한다.

  ````bash
  go mod init {모듈이름}
  go get github.com/gofiber/fiber/v3
  ````

  

### 서버 띄우기

Fiber 서버를 띄우는 기본적인 코드는 다음과 같다.

````go
package main

import "github.com/gofiber/fiber/v3"

func main() {
	
  // fiber 객체 생성
  app := fiber.New()

  // "/" url로 Get 요청이 왔을 시 동작할 handler 등록
  app.Get("/", func(c fiber.Ctx) error {
      return c.SendString("Hello, World!")
  })

  // http 요청을 받을 url 주소 설정 
  app.Listen(":3000")
}
````



## Basic Routing



라우팅이란 클라이언트에서 특정 endpoint로 요청이 왔을 때 어플리케이션이 어떻게 응답할 것인지 결정하는 것을 의미한다. 이때, 각각의 라우트(경로)는 여러 개의 handler function을 가질 수 있다.

먼저, Fiber의 라우팅 기본 구조를 살펴보겠다.

```go
// Function signature
app.Method(path string, ...func(fiber.Ctx) error)
```

- `app`는 Fiber의 객체이다. (`app := fiber.New()`)
- `Method`는 Http 요청 메소드를 의미하며, `GET`, `PUT`, `POST` 등이 있다.
- `path`는 서버에서의 url 경로이다.
- `func(fiber.Ctx) error` 는 콜백 함수로, 라우트가 일치하는 요청이 왔을 때 실행되는 정보를 가지고 있다.



### 파라미터 사용

```go
// GET http://localhost:8080/hello%20world

app.Get("/:value", func(c fiber.Ctx) error {
    return c.SendString("value: " + c.Params("value"))
    // => Get request with value: hello world
})
```

- 라우트에서 파라미터를 받고자 할 띠에는 경로 뒤에 `:변수명` 형식으로 파라미터를 지정한다.
- handler에서는 해당 변수를 fiber.Ctx 객체에서 `c.Params("{변수명}")` 으로 접근 가능하다



### 파라미터 optional 사용

```go
// GET http://localhost:3000/john

app.Get("/:name?", func(c fiber.Ctx) error {
    if c.Params("name") != "" {
        return c.SendString("Hello " + c.Params("name"))
        // => Hello john
    }
    return c.SendString("Where is john?")
})
```



### 멀티 파라미터 사용

```go
// http://localhost:3000/plantae/prunus.persica
app.Get("/plantae/:genus.:species", func(c *fiber.Ctx) error {
    fmt.Fprintf(c, "%s.%s\n", c.Params("genus"), c.Params("species"))
    return nil // prunus.persica
})

```

```go
// http://localhost:3000/flights/LAX-SFO
app.Get("/flights/:from-:to", func(c *fiber.Ctx) error {
    fmt.Fprintf(c, "%s-%s\n", c.Params("from"), c.Params("to"))
    return nil // LAX-SFO
})
```

- `.`와  `-`는 라우트에서 문자 그대로 인식되기 때문에, 위에서 처럼 파라미터 간 사이 지점을 구분하는 용도로 사용 가능하다



### Route 지정 시, wildcard 사용

wildcard(*) or plus(+) signs.s

### static file





















