# [토비의 스프링] 2장. 테스트



"토비의 스프링 3.1" 2장 테스트 단원을 읽고 정리한 글입니다.

책에서는 JUnit4 일 때의 코드로 작성되어 있어, 중간중간 책에 소개된 JUnit4 코드를 JUnit5로 어떻게 대체하는지에 대해서도 같이 정리하고자 합니다.



## 들어가며

해당 장은 테스트 케이스 작성의 중요성과 작성 방법에 대해서 다루고 있다.

테스트 케이스 강점으로는 크게 두가지가 있다. 

첫번째로는 **어플리케이션 변화에 유연하게 대처**할 수 있게 한다.

어플리케이션은 끊임없이 변화하고 복잡해져 간다. 확장과 변화를 고려한 객체지향적 설계로 변화에 빠르게 대응할 수 있다면, 테스트를 통해서 확실한 코드임을 보장할 수 있다. 

개발을 하다보면, 누구나 자신이 생각하지 못한 에러를 마주친 경험을 하게된다. 테스트 코드는 예상치 못한 에러를 방지하며, 자신이 작성/수정한 코드에 대해 확신을 가질 수 있게 해준다.

두번째로는 **전체적인 개발 속도를 증진**시킨다.

테스트 코드를 작성한다는 것은 부가적인 코드를 작성하는 것이기에 개발 시간이 늘어난다고 생각하기 쉽다. 하지만 테스트 코드는 상대적으로 작성하기 쉬울 뿐 아니라 빠른 오류 해결 속도를 가진다. 

테스트 코드는 전체 코드를 작은 단위로 쪼개서 이상여부를 확인할 수 있게 한다. 또한, 테스트의 작성과 테스트를 성공시키는 코드 작성의 주기를 최대한 짧게 유지함으로써, 개발한 코드의 오류를 조기에 발견하게 헤준다.



## [단위 테스트]



### 테스트 도구가 없을 때의 한계점

만약, 별도의 테스트 도구 없이 서버에 대한 테스트를 수행한다고 한다면, 다음과 같은 불편한 점들이 있을 것이다. 

1. 모든 레이어의 기능을 생성한 후 테스트가 가능하다.

   DAO를 개발하고 테스트를 하려면, 서비스 클래스, 컨트롤러, front까지 개발을 마친 후 서버를 실행하여 front에서부터 DB까지 잘 동작하는지 확인해야 한다.

2. 테스트의 결과를 수작업으로 확인해야 한다.

   수행 결과가 내가 원하는 결과와 맞는 값인지 눈으로 확인하거나, 엑셀 등에 수작업으로 결과를 작성해야 한다. 이러한 작업 방식은 미세한 차이를 식별하기 힘들며, 코드의 양과 복잡도의 증가시 개발자의 피로도도 올라갈 것이다.

이러한 테스트는 전체 프로세스에서 어디서 문제가 생겼는지 빠르게 확인이 불가능하며, 테스트의 반복적이고 빠른 실행이 불가능해 지속적인 개선 활동에 방해가 된다.



### 단위테스트

단위 테스트란 작은 단위로 쪼개어 테스트를 수행하는 것을 말한다. 여기서 단위란, 충분히 **하나의 관심**에 집중해서 효율적으로 테스트할 만한 범위를 의미한다. 이처럼 어디까지를 단위로 봐야한다 라는 명확한 기준점은 없지만 **관심사의 분리 원리가 적용된** 테스트라 생각하면 된다. 



### 단위테스트 프레임워크

단위테스트를 편리하게 실행해주는 도구로 JUnit과 같은 단위테스트 프레임워크가 존재한다. 

JUnit은 각각의 레이어의 기능이 완성되었을 때 즉각적으로 테스트할 수 있게 해주며, 수행 결과가 내가 예상한 결과와 일치하는지 자동으로 확인해준다. 

이를 통해서, 즉각적인 이상 여부 판단과 반복적인 테스트 수행이 가능해진다.



## [JUnit으로 테스트 코드 전환하기]



JUnit을 활용해서 테스트 메소드를 생성하기 위해서는 두가지 조건을 따라야 한다.

첫번째는, **public**으로 메소드를 선언하는 것이고, 두번째는 **@Test** 어노테이션을 테스트 메소드에 붙여주는 것이다.

```java
import org.junit.Test;

public class MyClassTest {
    
    @Test
    public void testMethod() throws SQLException {
    	// 테스트 코드    
    }
    
}
```



JUnit을 통해서는 다음과 같은 방법으로 내가 작성의 코드의 결과가 내가 예상하는 결과와 일치하는지 확인해준다.

### 1. 결과값에 대한 테스트

결과값에 대한 테스트는 `assertThat(T actual, Matcher<? super T> matcher)` 이라는 JUnit Static 메소드를 통해서 할 수 있다.

`assertThat`은 `actual` 이 matcher가 지정하는 조건을 만족하는지 판단한다.

예를 들어, `assertThat(user2.getName(), is(user.getName()));` 처럼 사용할 수 있다. `is()`라는 matcher는 `equals()`역할을 수행하여, `user2.getName()`와 `user.getName()`이 일치하면 테스트를 통과하게 된다.

JUnit5에서는 deprecated된 메소드이다.



:bulb: JUnit5에서의 결과값 테스트

- `assertTrue(boolean result, String message)`
  - result가 true시 테스트 성공한다. 실패 시, message 반환한다.
  - ex) `assertTrue(user2.getName().equals(user.getName()))`

- `assertFalse(boolean result, String message)`
  - result가 false시 테스트 성공한다. 실패 시, message 반환한다.



### 2. 예외 조건에 대한 테스트

코드가 동작하다보면, 특정 조건에서는 지정된 Exception이 발생해야 되는 경우가 존재한다. JUnit에서는 해당 코드가 지정된 Exception을 반환하였는지에 대한 테스트도 지원한다.

```java
@Test(expected=EmptyResultDataAccessException.class)
public void getUserFailure() throws SQLException {
    // 테스트 코드
}
```

`@Test(expected =  )` 안에  테스트 중에 발생할 것으로 기대하는 예외 클래스 지정함으로써, 해당 예외가 잘 발생하였는지 체크할 수 있다. 



:bulb: JUnit5에서의 예외 조건 테스트

- `Throwable assertThrows(Class<Throwable>, Executable)`
  - `Class<Throwable> ` 부분에 예상되는 Exception 클래스를 작성한다.
  - `Executable` 부분에  자신의 실행 코드를 lambda 식으로 작성한다.

```java
@Test
public void testMethod(){
    MyClass myClass = new MyClass();
    assertThrows(MyCustonException.class, () -> myClass.doSth());
}
```









예외조건에 대한 테스트

- 특정 예외가 던져지면 테스트 성공 / 정상 시, 실패라 판단해야 하는 경우

  ```java
  
  ```
  
  - `

테스트 코드 개선

- `@Before`

  - `@Test` 메소드가 실행되기 전에 먼저 실행돼야 하는 메소드를 정의

  - `@Test` 메소드에서 공통적으로 등장하는 변수는 인스턴스 변수로 선언한 후, `@Before`에서 정의

    => 반복적인 코드 제거

  ```java
  public class UserDaoTest{
      private UserDao dao;
      
      @Before
      public ovid setUp(){
          ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
          this.dao = context.getBean("userDao", UserDao.class);
      }
  }
  ```























## 스프링 테스트 적용



## 학습 테스트

