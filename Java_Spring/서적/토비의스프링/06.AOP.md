# AOP



"토비의 스프링 3.1" 6장 AOP 단원을 읽고 정리한 글입니다.

이 글에서는 AOP가 무엇이며, 어떤 과정과 원리를 통해서 현재의 모습까지 발전하였는지에 초점을 맞추어서 정리하였습니다. 책에서 추가적으로 다루는 팩토리 빈, @Transactional의 내용들은 별도의 글로 분리하였으며, 중간 과정들에 대한 테스트 코드 작성법과 현재는 자주 사용되지 않는 XML 빈 설정 방법은 생략하였습니다.



## 개요

AOP란 Aspect Oriented Programming의 줄임말로, **Aspect**라는 독특한 모듈을 **독립적으로 구분**해 내어 프로그램을 설계하고 개발하는 방법을 말한다. 여기서, Aspect란 프로그램의 핵심기능을 담고 있지는 않지만, 중요 구성 요소로서 부가기능을 담당하는 모듈을 의미한다. 

원래 부가기능이란 타깃이 존재해야만 의미 있는 종속적인 코드이다. 하지만 이를 부가기능을 정의하는 어드바이스와 적용 대상을 정의하는 포인트컷을 조합하여 Aspect라는 별도의 모듈로 분리해 냄으로 객체지향적 개발을 보조할 수 있게 했다.

이러한 AOP가 어떤 과정을 통해서 발전되었는지 차례대로 정리하고자 한다.



## DI 적용을 이용한 부가기능 분리



### 트랜잭션 경계설정과 비지니스 로직이 공존하는 메소드

저번 05.추상화 편에서 트랜잭션 추상화를 적용시킨 Service 코드를 다시 살펴보자

```java
public class UserService {
    private PlatformTransactionManager transactionManager;
    
    // 추후 PlatformTransactionManager은 bean으로 등록 후 @Autowired를 통해 주입 받음
    public void setTransactionManager(PlatformTransactionManager transactionManager){
    	this.transactionManager =transactionManager;
    }
    
    public void upgradeLevels(){
        TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
        try{
            List<User> users = userDao.getAll();
            for(User user : users){
                upgradeLevel(user); 	
            }
	        this.transactionManger.commit(status);
        } catch(RuntimeException e) {
            this.transactionManager.rollback(status);
            throw e;
        }

    }
}
```

해당 코드를 보면, 트랜잭션 경계 설정을 담당하는 코드와 비지니스 로직을 담당하는 코드로 뚜렷하게 구분이 가능하다. 이 두가지 코드간에는 서로 주고 받는 정보가 없는 상호 독립적인 코드기에, 비지니스 수행 코드가 트랜잭션 시작과 종료 사이에 수행되어야 한다는 원칙만 지켜진다면 분리시킬 수 있다. 



### 부가기능만을 책임지는 구현 클래스 생성

위와 같은 코드는 동일 인터페이스를 구현하지만 트랜잭션 경계설정이라는 책임만을 담당하는 클래스와 비지니스 로직을 수행하는 클래스를 분리시킴으로 할 수 있다. 

![image-20230911084031707](06.AOP.assets/image-20230911084031707.png)

[그림 6-3] 트랜잭션 경계설정을 위한 UserServiceTx의 도입



우선, 비지니스 로직 담당 클래스인 `UserServiceImpl`은 transaction 로직이 추가되기전 코드를 그대로 유지한다. 이로써, `UserServiceImpl`은 핵심 비지니스 기능에만 집중하는 코드가 된다.

```java
public class UserServiceImpl implements UserService {
    UserDao userDao;
    MailSender mailSender;
    
    public void upgradeLevels(){
        List<User> users = userDao.getAll();
        for(User user : users) {
            if(canUpgradeLevel(user)) {
                upgradeLevel(user);
            }
        }
    }
}
```

[리스트 6-4] 트랜잭션 코드를 제거한 UserSerivce 구현 클래스



부가기능인 트랜잭션 로직을 담당하는 `UserServiceTx` 클래스는 `UserServiceImpl`의 메소드를 부가기능 코드로 감싼다. 이로 인해, `UserServiceTx`은 오로지 트랜잭션 설정에만 책임을 가질 수 있다.

```java
publci class UserServiceTx implements UserService {
    UserService userService;
    PlatformTransactionManager transactionManager;
    
    public void setTransactionManager(PlatformTransactionManager transactionManager){
        this.transactionManager = transactionManager;
    }
    
    // UserSerivce를 구현한 다른 오브젝트는 DI 받는다
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
    
    // ...
    
    // 비지니스 로직을 수행하는 구현클래스의 메소드를 부가기능 코드로 감쌈
    public void upgradeLevels(){
        TransactionStatus status = this.transactionManger.getTransaction(new DefaultTransactionDefinition());
        try {
            userService.upgradeLevels(); // 비지니스 로직은 DI 받은 오브젝트에 위임
            this.transactionManger.commit(status);
        }catch (RuntimeException e){
            this.transactionManger.rollback(status);
            throw e;
        }
    }
}
```

[리스트 6-5] 위임 기능을 가진 UserServiceTx 클래스



이후 Client가 `UserService` 인터페이스를 통해 사용자 관리 로직을 실행할 때, 트랜잭션 담당 오브젝트가 호출되어 선 트랜잭션 작업 후 실제 비지니스 오브젝트를 통해 로직을 수행하는 구조로 로직을 수행한다.



























