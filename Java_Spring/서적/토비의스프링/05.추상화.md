# [토비의 스프링] 5장. 추상화



"토비의 스프링 3.1" 5장 추상화 단원을 읽고 정리한 글입니다.

책에서는 4장까지 완성된 DAO에 기능 추가 및  추상화 과정을 소스를 조금씩 수정하며 설명하지만, 본 글에서는 최종 주제인 **수평/수직적 분리**에 대한 내용 위주로 정리하였습니다. 또한 테스트를 위한 추상화는 오늘날에는 Junit에서 기능을 제공하기 때문에 생략하였습니다.



## 들어가며

### 수평, 수직적 분리

이번 장의 목표는 수평, 수직 계층 구조의 객체 간 관계를 추상화를 통한 분리로 서로의 결합도를 낮추는 것이다. 

수평적 분리는 같은 계층 내에서 기능적 관심에 따라 분리하는 것이다. 예를 들어, `UserService`와 `UserDao`는 애플리케이션 로직을 담은 애플리케이션 계층에 있지만 각각 사용자 비지니스 로직과 데이터 엑세스 로직이라는 기능을 맡고 있다. 이때, 서로 다른 관심을 가지는 클래스들의 관계에서는 한쪽의 로직이 변하여도 다른 쪽의 소스에 영향을 주지 않아야 한다.

수직적 분리는 다른 계층의 특성을 갖는 코드를 분리하는 것이다. 예를 들어, `UserService`와 `UserDAO`와 같은 기능을 수행하는 계층과 `JDBC`, `JTA`, `WAS`, `Hibernate`와 같은 기술 계층을 분리하는 것이다. 애플리케이션 계층의 소스가 특정 기술에 종속되는 것이 아닌, 사용하는 기술이 변하여도 애플리케이션 계층의 소스를 수정하지 않도록 분리하는 것이다.

이러한 수평적, 수직적 분리는 모두 추상화와 DI로 구현할 수 있다. 이를 통해, 소스간 결합도를 낮추고, 자유로운 확장 구조를 생성하며,  하나의 모듈이 바뀌는 이유는 하나여야 한다는 단일 책임 원칙을 지킬 수 있다.



### 코드 개선 질문

이처럼 추상화는 객체 지향적으로 코드를 잘 작성하기 위해서 필수적인 개념이다. 자신의 코드가 추상화를 통해 낮은 결합도와 높은 응집도를 가진 코드인지 확인하기 위해서는 다음과 같은 질문들을 던져보면 좋다.

- 코드에 중복된 부분은 없는가
- 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가
- 코드가 자신이 있어야 할 자리에 있는가
- 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가



## 수평적 분리 예시 (feat. Service 다중 역할 코드 개선)

### 코드 배경

사용자 등록, 조회, 수정, 삭제만 있던 기존 로직에 사용자 관리의 일환으로 레벨을 조정할 수 있는 기능을 추가한다고 해보자. 사용자 레벨에는 "BASIC", "SILVER", "GOLD"가 있다. 이때, DB 상에서 해당 문자열로 레벨을 관리하는 것은 DB용량이 비효율적이므로, 1,2,3과 같은 숫자로 코드화해서 관리한다. Java 소스 상에서는 Enum을 활용해서, 레벨과 코드 숫자를 관리할 수 있다.

```java
public enum Level {
    GOLD(3), SILVER(2), BASIC(1);
    private final int value;

    public int getValue(){
        return this.value;
    }
}
```



### 높은 결합도 예시 코드

이제, 기존 User의 레벨을 높이기 위해서는 다음과 같은 코드를 짤 수 있다.

```java
public class UserService {
    // ...
    
    private void upgradeLevel(User user){
        if(user.getLevel() == Level.BASIC){
            user.setLevel(Level.SILVER);
        } else if (user.getLevel() == Level.SILVER) {
            user.setLevel(Level.GOLD);
        }
        userDao.update(user);
    }
    // ...
}
```

[리스트5-25] 레벨 업그레이드 작업 메소드



하지만, 이와 같은 소스에는 두가지 문제점이 존재한다. 

첫번째로, UserService에 과도한 역할이 모여있다. 다음 단계가 무엇인가 하는 로직과 사용자 level 변경 로직이 함께 존재하고 있다. 이와 같은 코드에서는 `UserService`의 기존 관심도인 각 주체에게 요청을 내린 것 이외에, Level이 추가되거나, Level간 순서에 변경이 있을 때에도 수정이 필요할 것이다.

두번째로, 예외 상황에 대한 처리가 없다. Level의 변경함에 있어 생길 수 있는 예외 상황의 처리 또한 적절한 관심사를 가진 객체에 귀속되어야 한다.



### 개선 방안

이러한 문제점을 해결하기 위해서는, 각각의 역할을 해당하는 관심사를 가지는 모듈로 이동시켜야 한다.

첫번째로, **레벨의 순서와 다음 단계 레벨이 무엇인지 결정**하는 역할은 `Level`에 이동시킬 수 있다.

```java
public enum Level {
    GOLD(3, null), SILVER(2,GOLD), BASIC(1,SILVER);
    private final int value;
    private final Level next;

    // ...
    public Level nextLevel(){
        return this.next;
    }
}
```



두번째로, **사용자 정보를 수정 및  사용자 정보 처리 과정 중 발생하는 예외 처리**는 `User`에게 맡길 수 있다.

```java
public void upgradeLevel(){
	Level nextLevel = this.level.nextLevel();
    if(nextLevel == null) {
        throw new IllegalStateException();
    } else {
        this.level = nextLevel;
    }
}
```



세번째로, `UserService`는 각 주체들에게 요청하는 역할만을 가진다.

```java
private void upgradeLevel(User user){
	user.upgradeLevel();
    userDao.update(user);
}
```



이렇게 수정이 된다면, 각각의 모듈들은 변경해야 할 이유를 단 하나씩만 가질 수 있게 된다. `Level`은 Level의 관리 체계 변경이 있을 때, `User`는 사용자 관리의 변경이 있을 때, `UserService`는 User 관련 비지니스 로직의 추가 및 변경이 있을때만 수정을 하면 된다. 각 주체들이 하나의 책임만 가지게 되는 것이다.





## 수직적 분리 예시 (feat. Service 트랜잭션 서비스 추상화)

### 코드 배경

한번에 한명의 User에 대한 정보를 수정하는 것이 아니라 한꺼번에 여러 명의 정보를 수정하고, 한명에 대한 수정이 실패가 났을때에는 전부 원복을 시켜야 하는 경우에는, 각각의 작업을 하나의 트랜잭션으로 묶어야 할 것이다. 하지만 트랜잭션은 커넥션보다 존재 범위가 짧기 때문에, 메소드 단위로 connection을 반환하는 구조에서는 여러 메소드를 한 트랜잭션으로 처리할 수가 없게 된다. 

만약, 스프링의 도움 없이 여러 메소드를 하나의 메소드로 처리하기 위해서는 다음 2가지 방법이 있을 것이다.

첫번째로, DAO 안에 Service 안에 있던 비지니스 로직을 옮기는 것이다. Connection을 가지는 DAO 내에서 DB 작업 뿐만 아니라 여러 비지니스 로직을 전부 처리하고 Commit을 한다면, 하나의 트랜잭션으로 묶어서 처리할 수 있을 것이다.



### 기술 종속적 예시 코드









### 개선 방안

































