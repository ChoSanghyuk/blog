# 1장. 오브젝트와 의존관계



"토비의 스프링 3.1"을 읽고서 내용을 정리한 글입니다. 

잘못된 사례부터 시작하여, 점차 코드를 개선해 나가며 내용을 설명했던 본래 글과 다르게, 해당 장에서 반복적이고 공통적으로 등장하는 주제들을 내용 중심으로 정리하고자 합니다.



## 들어가며

해당 장은 객체 지향적인 설계를 할 때, 오브젝트들과 오브젝트들의 의존 관계를 어떻게 설계하면 좋을지에 관한 내용을 다루고 있다. 

객체 지향적 설계 원칙 중 **단일 책임 원칙**에 따르면 객체는 하나의 관심사에 집중되어야 한다. 하지만 대규모 프로그램을 설계하면, 객체들은 독립적으로 자신의 관심사를 수행하는 것이 아닌, 다른 객체들과의 관계(의존)를 통해서 수행하는 경우가 자주 존재한다. 하지만 이러한 관계 또한 하나의 관심사로써, 객체 내에서 **직접적인 의존관계를 가지는 것은 자신의 핵심 관심사 외의 다른 관심사를 가지는 것**이다. 

의존관계가 필수인 상황에서, 어떻게 스프링은 객체들이 핵심 관심사에 집중할 수 있게 만들어 주는지가 이 장의 핵심 내용이다. 



## 관심사의 분리

객체의 응집도를 높이기 위해서 필요한 과정은 관심사를 분리 시키는 것이다.  응집도란 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 말하며, 하나의 관심사(목적)를 위해 긴밀하게 협력하는 가를 나타낸다.  관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 함으로써 응집도를 높일 수 있다.

관심사를 분리시킴으로 얻을 수 있는 장점은 변화의 폭을 최소한으로 줄일 수 있다는 것이다. 변화는 대체로 한가지 관심에 대해서 일어난다. 관심사가 분리되어 있다면, 추후 프로그램에 대한 요구사항이 변하였을 때, 프로그램의 변경을 최소화 시킬 수 있다. 



방법으로는 크게 두 가지가 있다. 

첫번째는 상속을 통한 확장이다. 공통적인 기능은 부모 클래스에서 정의하고, 상황에 따라 달라지는 관심사는 자식 클래스에서 정의한다. 이때 활용되는 디자인 패턴은 **템플릿 메소드 패턴**으로, 변하지 않는 기능은 슈퍼클래스에 두고, 자주 변경되면 확장할 기능은 서브클래스에서 구현하는 패턴이다. 

예를 들어, DAO가 수행하는 SQL은 정해져있지만 Connection 연결만이 상황에 따라 달라질 때, 공통적인 SQL 수행 부분은 부모 클래스에서 정해두고, A Connection과 관계를 맺을 지, B Connection과 관계를 맺을지는 자식 클래스에서 결정하는 방식이다. 이때, 부모 클래스에서는 Connection 연결 부분을 추상 메소드나 오버라이딩이 가능한 protected 메소드로 남겨둠으로써, 자식 클래스에서 오버라이딩이 가능하게 한다.

하지만, 상속을 통한 방법은 다중 상속이 불가능하다는 점과 상하위 클래스끼리 두 가지 다른 관심사에 대해 긴밀하게 결합되어 있다는 한계가 존재한다. 



두번째로는 인터페이스를 통한 확장이다. 클래스 사이의 관계는 코드에 다른 클래스 이름이 나타나기 때문에 생성된다. 이때, 인터페이스 타입으로 참조 시, 느슨한 관계를 유지할 수 있다. 모델링 시점에는 존재하지 않았던 관계가 런타임 시점 때 생성되는 것이다. 이때 활용되는 디자인 패턴은 **전략 패턴**으로 , 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스 통째로 외부로 분리시키는 방법이다. 









제어의 역전

- 제어권의 이전을 통한 제어관계 역전

  - 프로그램의 제어 흐름 구조가 뒤바뀌는 것


  - **능동적 주체 => 수동적 주체**

  - 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정, 언제/어떻게 그 오브젝트를 만들지를 스스로 관장

    => 모든 제어 권한을 자신이 아닌 다른 대상에게 위임

- 라이브러리 vs 프레임워크

- 스프링의 IoC

  - 

  





















