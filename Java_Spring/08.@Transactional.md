# [Spring] @Transactional



## 개념

### 트랜잭션

트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다. 

트랜잭션의 주요 특징으로는 원자성이 있다. 원자성은 **더 이상 나눌 수 없는 작업 단위**를 나타내는데, 이는 해당 작업이 중간까지만 실행되는 일 없이, 완전하게 실행되거나 전혀 실행되지 않음을 뜻한다. 

따라서, 우리가 소스의 비지니스 로직을 처리하기 위한 SQL문들을 하나의 트랜잭션으로 묶는다면, 비지니스 로직을 처리함에 있어 데이터베이스의 데이터 일관성과 안전성을 보장할 수 있게 된다.



:bulb: 트랜잭션의 중요 특징

- 원자성 (Atomicity): 모든 연산이 완전하게 실행되거나 전혀 실행되지 않음
- 일관성 (Consistency): 트랜잭션이 데이터베이스를 유효한 상태로 변경해야 하며, 일관성 규칙을 위반하지 않아야함
- 독립성 (Isolation): 다중 트랜잭션이 동시에 실행될 때, 각 트랜잭션은 다른 트랜잭션의 실행 결과에 영향을 미치지 않음
- 지속성 (Durability): 트랜잭션이 성공적으로 완료된 후에는 그 결과가 영구적으로 저장



### @Transactional

`@Transactional`은 스프링에서 어노테이션 방식으로 트랜잭션을 처리하기를 위한 **선언적 트랜잭션**의 일종이다. 여기서, 선언적 트랜잭션이란 설정 파일 or 어노테이션 방식으로 간편하게 트랜잭션에 관한 행위를 정의하는 것이다.

`@Transactional`은 Spring AOP방식으로 구현되었다. 여기서 AOP란, Aspect Oriented Programming의 줄임말로, **Aspect**라는 독특한 모듈을 **독립적으로 구분해 내어 프로그램을 설계하고 개발하는 방법**을 말한다. Aspect는 부가기능을 정의하는 어드바이스와 적용 대상을 정의하는 포인트컷을 조합하여 구성된다. 이에 `@Transactional`  또한, 트랜잭션 설정이라는 부가기능을 담당하는 어드바이스와  `@Transactional`이 부착된 대상을 적용대상으로 정의하는 포인트컷으로 구성되어 있다.



:bulb: 선언적 트랜잭션 없이 직접 트랜잭션 설정하기

Spring은 여러 DMBS들의 트랜잭션 경계 설정 방법에서 공통적인 특징을 모아서 추상화된 트랜잭션 관리 계층을 제공해 준다. PlatformTransactionManager



```java
public class UserService {
    private PlatformTransactionManager transactionManager;
    
    // 추후 PlatformTransactionManager은 bean으로 등록 후 @Autowired를 통해 주입 받음
    public void setTransactionManager(PlatformTransactionManager transactionManager){
    	this.transactionManager =transactionManager;
    }
    
    public void upgradeLevels(){
        TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
        try{
            List<User> users = userDao.getAll();
            for(User user : users){
                upgradeLevel(user);
            }
	        this.transactionManger.commit(status);
        } catch(RuntimeException e) {
            this.transactionManager.rollback(status);
            throw e;
        }

    }
}
```

[리스트 5-45] 스프링의 트랜잭션 추상화 API를 적용한 upgradeLevels()





## @Transactional 동작 원리



### @Transactional 동작 방법



### @Transactional의 4가지 속성

`@Transactional`이 ~~하는 `TransactionDefinition` 인터페이스는 트랜잭션의 동작 방식에 영향을 줄 수 있는 네 가지 속성을 정의할 수 있다.

첫번째로는 **트랜잭션 전파**이다. 트랜잭션 전파란, 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 혹은 없을 때 어떻게 동작할 것인지를 결정하는 방식이다. 스프링에는 다음의 총 7가지 전파 속성이 존재한다.

- `PROPAGATION_REQUIRED`
  - 진행 중인 트랜잭션 있으면 참여하고, 없으면 새로 시작한다.
  - 가장 많이 활용되는 전파 속성
- `PROPAGATION_REQUIRES_NEW`
  - 항상 새로운 트랜잭션 시작한다.
  - 별도의Connection을 추가적으로 연결해서 사용하기 때문에 커넥션 고갈의 위험이 있다.
  - REQURES_NEW 없이 해결 가능하다면 대안책(별도의 클래스를 두기 등)을 사용하는 것이 좋다.
- `PROPAGATION_SUPPORTS`
  - 진행 중인 트랜잭션 있으면 참여하고, 없으면 트랜잭션 없이 진행한다.
- `PROPAGATION_NOT_SUPPORTED`
  - 트랜잭션 없이 동작하도록 만들며, 진행 중인 트랜잭션이 있어도 무시한다.
  - 특정 메소드만 트랜잭션 적용에서 예외 처리 할 때 사용한다.

- `PROPAGATION_MANDATORY`
  - 진행 중인 트랜잭션 있으면 참여하고, 없으면 `IllegalTransactionStateException ` 예외 발생시킨다.
- `PROPAGATION_NEVER`
  - 진행 중인 트랜잭션 있으면 `IllegalTransactionStateException` 예외를 발생시키고, 없으면 트랜잭션 없이 진행한다.

- `PROPAGATION_NESTED`

  - 진행 중인 트랜잭션 있으면 중첩 트랜잭션을 만들고, 없으면 트랜잭션을 새로 생성한다.

  :bulb:중첩 트랜잭션 : 중첩 트랜잭션은 부모 트랜잭션의 영향(커밋과 롤백)을 받지만, 중첩 트랜잭션이 외부에 영향을 주지는 않는다.



두번째로는 **격리수준**이다. 격리수준이란, 트랜잭션들이 순차적으로 독립적이게 실행될 것인지, 한꺼번에 동시에 진행할 것이지에 대한 정도를 의미한다. 성능 상, 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 제어가 필요하다. 스프링은 다음의 5가지 격리수준 속성을 지원한다.

- `ISOLATION_DEFAULT`
  - DataSource에 설정되어 있는 디폴트 격리 수준 따른다 (대부분의 DB는 `READ_COMMITED`를 기본 격리수준으로 갖는다.)
- `ISOLATION_READ_UNCOMMITTED`
  - 하나의 트랜잭션이 커밋되기 전에 그 변화가 다른 트랜잭션에 그대로 노출된다.
  - 가장 낮은 격리수준을 가짐
  - 가장 빠르기 때문에 데이터의 일관성이 조금 떨어지더라도 성능을 극대화할 때 의도적으로 사용한다.
- `ISOLATION_READ_COMMITTED`
  - 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음

- `ISOLATION_REPEATABLE_READ`
  - 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 로우를 추가하는 것은 막지 않음
- `ISOLATION_SERIALIZABLE`
  - 트랜잭션을 순차적으로 진행시킴
  - 가장 강력한 트랜잭션 격리 수준
  - 가장 안전하지만 가장 성능이 떨어지므로 극단적으로 안전한 작업이 필요한 경우가 아니라면 사용 지양



세번째는 **제한시간**이다. 트랜잭션 수행의 제한시간을 설정할 수 있으며, 기본 설정값은 제한시간 없음이다. 제한시간 속성은 **처음 트랜잭션이 시작할 때만 적용**되며 그 이후의 설정은 무시된다. 예를 들어, 트랜잭션 tiemout이 10초인 트랜잭션이 먼저 시작되고 그 이후 60초인 트랜잭션이 참여하게 된다면, 제한 시간은 첫 트랜잭션의 값인 10초로 설정되고 60초는 무시된다.



네번째는 **읽기전용**이다. 해당 속성은 트랜잭션 내 데이터를 조작하는 시도를 막거나, 데이터 엑세스 기술에 따라서 성능 향상을 위해 사용된다. 이 속성 또한 처음 트랜잭션이 시작할 때만 적용되며, 그 이후의 설정은 무시된다.



## @Transactional 사용 예시





## 트랜잭션 지원 테스트









- MangKyu, [Spring] 스프링의 트랜잭션 전파 속성(Transaction propagation) 완벽하게 이해하기, https://mangkyu.tistory.com/269

MangKyu,[Spring] Spring 트랜잭션의 세부 설정(전파 속성, 격리수준, 읽기전용, 롤백/커밋 예외 등) - (2/3),https://mangkyu.tistory.com/169
