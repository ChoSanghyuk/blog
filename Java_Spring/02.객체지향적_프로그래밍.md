# 객체 지향적으로 코드 작성하기



회사에서 자바로 프로그램을 작성하던 중 문득 이런 생각이 들었다.

"나는 자바답게 프로그램을 작성하고 있는가"

자바는 객체 지향 프로그래밍 언어인데, 나는 객체 지향적으로 코드를 작성하기 위해 얼마나 노력하고 있었나 라는 생각이 들었다.

이번 기회에, 객체 지향적이란 무엇인지에 대해 다시 한번 복습해보고자 한다.



## 객체 지향 프로그래밍이란



객체란 우리 주변에 있는 모든 것을 말한다. 객체 지향적 프로그래밍이란, 객체가 데이터와 로직을 수행하는 함수를 가지게 하여 해당 객체들의 상호작용을 통해 프로그램을 설계하는 것이다. 즉, 프로그래밍 로직이 진행될 때, 기능이 아닌 객체가 중심이 되어 **어떤 객체**가 **무슨 일을 수행**할지에 초점을 맞춰서 설계하는 것이다.



반대되는 개념으로는 절차 지향적 프로그래밍이 있다. 절차 지향은 **기능중심**으로 바라보는 방식으로, 무엇을 어떤 절차로 할 지에 초점을 맞춰서 설계한다. 

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F998992425B3768AA23)



출처 : https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F998992425B3768AA23



객체 지향적 프로그래밍은 높은 재사용성, 생산성, 유지보수성을 가지기에 대규모 프로젝트에 용이하다. 하지만 소규모 프로젝트에서는 모든 것을 객체로 작성해야 해서 비효율 발생할 수 있다. 



## 객체 지향 프로그래밍의 특징



객체 지향 프로그래밍의 특징으로 다음과 같이 4가지가 있다.



### 추상화

추상화의 사전적 정의는 "주어진 문제나 시스템을 중요하고 관계 있는 부분만 분리해 내어 간결하고 이해하기 쉽게 만드는 작업" 이다(출처 :네이버사전). 이는, 핵심과 공통 부분을 따로 추출하는 것으로, 프로그래밍 관점으로는 **객체의 공통적인 속성과 기능을 추출하여 정의하는 것**이다. 

추상화의 방법으로는 크게 두 가지가 있는데, 상속과 인터페이스이다. 상속을 통해서 하위 클래스들의 공통적인 속성과 기능을 부모 클래스로 추출할 수 있으며, 인터페이스를 통해서 객체들이 수행해야 하는 핵심적인 역할들을 따로 규정할 수 있게 된다. 특히, 인터페이스는 역할만을 규정하고 실제 구현은 해당 인터페이스를 구현하는 각각의 객체하는 하도록 하여, **역할과 구현을 분리**시킨다. 



### 상속

상속은 클래스 간 **공유될 수 있는 속성과 기능들을 상위 클래스로 추상화** 시켜 해당 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있게 하는 것이다. 이를 통해서, 반복적인 정의 없이 재사용할 수 있으며, 공유하는 속성과 기능에 간편하게 접근할 수 있게 된다. 



하지만 상속을 한다 해서, 부모의 모든 속성과 기능을 그대로 받는 것은 아니다. 부모 클래스에서는 private 접근 제어자를 통해 상속시키지 않을 속성과 메소드를 지정할 수 있다. 또한 자식 클래스에서도 부모의 모든 메소드를 그대로 받는 것이 아닌, 메서드 오버라이딩(method overriding)을 통해 내용을 재정의 할 수 있다.



### 다형성

다형성이란 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것을 의미한다. 좀 더 구체적으로, 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것이다. 예를 들어, Player 클래스를 BaseballPlayer, SoccerPlayer가 상속받는다 하겠다.

```java
Player player = new BaseballPlayer();
player = new SoccerPlayer();
```

위와 같이, player변수는 Player클래스 타입의 객체이지만, 참조하는 객체는 BassbllPlayer 타입이 될 수도 SoccerPlayer 타입이 될 수도 있다. 



이러한 다형성을 통해 코드를 작성했을 경우 두가지 장점이 있다. 



첫번째로, 하나의 타입만으로 하나의 타입만으로 여러 가지 타입의 객체를 참조할 수 있어 보다 **간편하고 유연하게 코드**를 작성하는 것이 가능해진다.

```java
// 예시 1. List
List<Player> list = new ArrayList<>();
list.add(new BaseballPlayer());
list.add(new SoccerPlayer());

// 예시 2 method
public void play(Player player){ // 매개변수에 BaseballPlayer, SoccerPlayer 타입 변수 사용 가능.
    // ...
}
```

이처럼 Player 타입을 받는 클래스, 메소드에 자식 클래스들을 넣을 수 있게 되면서, 더 유연하게 코드를 작성할 수 있게 된다. 



두번째로, 객체들간의 **결합도를 낮출 수** 있다. 

A라는 클래스가 B타입의 변수를 직접적으로 참조해 사용한다면,  A 클래스는 B 클래스에 의존한다 하고, 두 객체간 결합도가 높다 라고 말한다. 하지만 A 클래스가 B 타입만의 속성/메소드를 사용하는 것이 아닌 다른 타입들과의 공통적인 특징을 사용한다면, B 타입의 부모 클래스 혹은 인터페이스 타입을 참조함으로써 결합도를 낮출 수 있다. 



### 캡슐화

캡슐화는 서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것이다. 캡슐화는 **접근제어자**와 **getter/setter** 메서드를 통해서 구현이 가능하다.

priavate, default, protected, public의 접근제어자로 외부의 노출 정도를 정할 수 있으며, getter/setter 메소드를 통해서 직접적인 노출을 피한 속성들에 대해서 외부의 접근 수정을 허락할 수 있게 된다. 





## 객체 지향 프로그래밍의 5가지 설계 원칙



그렇다면 마지막으로 위와 같은 특징을 가진 객체 지향 프로그램을 잘 작성하기 위해서라면 어떻게 해야 할까. 객체 지향 프로그래밍에는 SOLID라 불리는 5가지 원칙이 있다. 



### 단일 책임의 원칙(SRP, Single Responsibility Principle)

단일 책임 원칙은 하나의 모듈이 하나의 책임을 가진다라고 주로 해석되지만, 실제의 의미는 모듈이 변경되는 이유가 한가지여야 함이다. 모듈이 변경되는 이유가 한가지가 되기 위해서는, 해당 모듈이 여러 액터들에 대해 책임을 가지지 않고, 오직 한 가지의 액터에 대해서만 책임을 져야 하는 것이다. 

어떤 하나의 모듈에서 여러가지의 요구사항을 모두 처리하고 있다면, 해당 모듈을 변경하게 되는 되는 이유는 요구사항의 수 만큼 있을 수 있다. 하지만, 단 하나의 역할만 가짐으로써 특정 요구사항의 변화가 있을 때, **명확한 하나의 수정 대상**을 가질 수 있다. 이는 곧 모듈을 응집도 높게 작성하게 되는 것이다.





### 개방 폐쇄 원칙 (Open-Closed Principle, OCP)

개방 폐쇄 원칙은 **확장에 열려있고, 수정에 닫혀있어야 한다**는 원칙이다. 확장에 열려있다는 것은 요구사항이 변경될 때 새로운 동작을 추가하여 기능을 확장할 수 있는 것이며, 수정에 닫혀있다는 것은 기존의 소스를 수정하지 않고, 동작의 추가 및 변경을 하는 것이다.

새로운 동작을 추가하여 기능을 확장하는 것은 직관적으로 이해되는 반면 기존의 소스를 수정하지 않고, 동작의 추가와 변경을 수행하는 것은 바로 와닿지는 않는다. 여기에서 **추상화**의 개념이 다시 사용된다. 

추상화없이 A라는 클래스가 B라는 클래스에 직접적으로 의존하는 경우, B 클래스에 변경이 있거나 새로운 C 클래스를 사용해야 할 경우, B와 C랑은 상관없는 A 클래스까지 수정이 필요해진다. 이렇게 결합도 높은 상태에서는 개방 폐쇄 원칙을 지키기 어렵다.

하지만, A 클래스가 처음부터 역할만을 추출한 Interface에 의존하고 있었다면, 아무리 많은 수의 구현 로직과 구현 클래스들이 생성되어도 A 클래스의 수정없이 사용 가능해진다.





### 인터페이스 분리 원칙 (Interface segregation principle, ISP)

인터페이스 분리 원칙이란 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 적절하게 분리시켜 주는 것이다. 다시 말해, 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것이다. 

예를 들어서, 파일 작업이라는 일의 구현체로 A 클래스는 읽기와 쓰기를, B 클래스는 쓰기만을 구현하고 있다면은 인터페이스도 읽기와 쓰기로 구분하는 것이다. 만약 읽기와 쓰기를 모두 하는 인터페이스를 B 클래스가 구현하게 된다면, B 클래스에는 필요없는 읽기에 대한 구현이 들어간다. 반대로 쓰기만 하는 인터페이스를 A 클래스와 B 클래스가 구현한다면, 읽기 기능에 대해서 A 클래스는 역할과 구현이 분리가 되지 않으며, 추후 새로 쓰기 구현 클래스가 필요할 경우 개방 폐쇄 원칙을 지키기 어렵게 된다. 

이렇게 인터페이스 분리 원칙을 통하여, 모든 클라이언트가 자신의 관심에 맞는 인터페이스만을 접근하여 불필요한 간섭을 최소화시킬 수 있다. 



### 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)

리스코프 치환 원칙은 **하위 타입은 상위 타입을 대체**할 수 있어야 한다는 것이다. 처음 봤을 때에는 자바는 다형성을 가지므로 당연히 하위 타입이 상위 타입을 대체할 수 있는 것 아니야 라는 생각을 하였다. 하지만, 여기서 말하는 바는 자바의 기능적인 대체가 아닌 논리적인 대체를 의미하다. 

예를 들어, 정사각형은 직사각형의 모든 성질을 상속받는 자식 클래스이다. 하지만, 사람들은 일반적인 직사각형이라는 가로와 세로가 다른 사각형을 생각하기 때문에, 정사각형이 직사각형을 대체하여 사용하는 데 문제가 생길 수 있다.

코드로 구현하자면, 다음과 같이 직사각형과 직사각형을 상속받는 정사각형 클래스가 있다. 

```java
@Getter
@Setter
@AllArgsConstructor
public class Rectangle {

    private int width, height;

    public int getArea() {
        return width * height;
    }

}

public class Square extends Rectangle {

    public Square(int size) {
        super(size, size);
    }
	
    @Override
    public void setWidth(int width) {
        super.setWidth(width);
        super.setHeight(width);
    }

    @Override
    public void setHeight(int height) {
        super.setWidth(height);
        super.setHeight(height);
    }
}
```

여기서 정사각형은 가로와 세로 둘 중 하나만 입력받아도 가로와 세로가 모두 설정이 된다. 하지만 사람들이 직사각형에 기대하는 것은 가로와 세로에 서로 다른 값을 설정하였을 때, 가로,세로에 각각 자신이 설정한 값이 설정되는 것이다. 

```java
public void resize(Rectangle rectangle, int width, int height) {
    rectangle.setWidth(width);
    rectangle.setHeight(height);
    if (rectangle.getWidth() != width && rectangle.getHeight() != height) {
        throw new IllegalStateException();
    }
}
```

따라서 아래와 같이, 직사각형을 정사각형으로 대체하여 resize를 수행하는 경우, 사람들이 직사각형에 원하는 논리대로 구현되지 않을 것이다. 

```java
Rectangle rectangle = new Square();
resize(rectangle, 100, 150);
```

코드 출처 : https://mangkyu.tistory.com/194



이렇게 리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다. 항상 클라이언트 사이드로 생각하면서 대체 가능성에 대해 고려해 보아야 한다. 





### 의존 역전 원칙 (Dependency Inversion Principle, DIP) 

의존 역전 원칙이란 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 되며, 저수준 모듈이 고수준 모듈에 의존해야 한다는 것이다.

여기서 고수준 모듈과 저수준 모듈은 다음과 같다. 

- 고수준 모듈: 입력과 출력으로부터 먼(비즈니스와 관련된) 추상화된 모듈
- 저수준 모듈: 입력과 출력으로부터 가까운(HTTP, 데이터베이스, 캐시 등과 관련된) 구현 모듈



다시 말해, 비지니스와 관련된 모듈이 세부 사항(구현체)에 의존하지 않게 설계하는 것이다. 비지니스와 관련된 핵심 영역이 다른 모듈의 변경이 있을 때 영향도가 최소가 되게끔, 추상화에 된 부분에 의존해야 한다. 이는 앞서말한 개방 폐쇄 원칙과 밀접한 관계를 가진다.











객체 지향에 대해서 다시 공부하며 느낀점은 다 알고 있다 생각한 내용들에 대해서 내가 너무 모르고 있었구나 이다. 이전 정보처리기사 시험을 볼 때 그렇게 외웠던 내용들이지만, 정의만 알고 속뜻은 모르고 있었다. 내가 작성하는 코드가 이렇게 짜는게 맞나 라는 생각과 함께 다시 공부해 보니 그때 외웠던 용어들이 이해되는 느낌이다.



공부한 내용을 한줄로 요약하면 객체 지향 프로그래밍이란 "역할과 구현을 구분하여 객체들 간의 직접적인 결합을 피하고, 느슨한 관계 설정을 통해 보다 유연하고 변경이 용이한 프로그램으로 설계하는 것"이다. 앞으로는 추상화와 다형성에 유념하며 코드를 작성해야 겠다.





해당 글은 다음의 자료들을 공부, 요약하여 작성되었습니다.

- 人CoDOM, 객체 지향, https://www.incodom.kr/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5
- codestates, 객체 지향 프로그래밍의 4가지 특징,https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95
- 망나니 개발자, 객체지향 프로그래밍의 5가지 설계 원칙, 실무 코드로 살펴보는 SOLID, https://mangkyu.tistory.com/194



