# [마스터링 이더리움] 6장. 트랜잭션



본 포스트는 서적 *마스터링 이더리움*의 6장 *트랜잭션* 파트를 정리한 포스트입니다. 



## 트랜잭션 개요



트랜잭션이란, 외부 소유 계정(EOA)에 의해 서명된 메시지이다. 트랜잭션은 네트워크에 의해 전송되고 이더리움 블록체인에 기록되어 진다. 

트랜잭션은 EVM에서 상태 변경을 유발하거나 컨트랙트를 실행할 수 있는 유일한 방법이다. 이더리움은 글로벌 싱글톤 상태 머신인데, 트랜잭션은 이 상태 머신을 움직여서 상태를 변경시킨다. 다시 말해, 이더리움에서 모든 것은 트랜잭션으로부터 시작된다. 



### 구조

트랜잭션의 기본 구조는 다음과 같다. 

- **논스**(nonce)
  - 메시지 재사용을 방지하는 데 사용되는 일련번호
- **가스 가격**(gas price)
  - 발신자가 지급하는 가스의 가격
- 가스 한도(gas limit)
  - 이 트랜잭션을 위해 구입할 가스의 최대량
- **수신자**(recepient)
  - 목적지 이더리움 주소
- **값**(value)
  - 목적지에 보낼 이더의 양
- **데이터**(data)
  - 가변 길이 바이너리 데이터 페이로드

- **v,r,s**
  - EOA의 ECDSA 디지털 서명의 세 가지 구성요소



:bulb: 만약 내부 정보를 보여주거나 사용자 인터페이스를 시작화하기 위해서는 트랜잭션 구조 이외에도 트랜잭션이나 블록첸인에서 파생된 추가 정보를 사용해야 한다. 예를 들어, 트랜잭션에는 발신자 정보가 없는데, 발신자 정보를 보여주기 위해서는 v,r,s 구성요소로부터 발신자 정보를 알아내서 표시해야 한다. 



### 수신자

트랜잭션의 to 필드에 트랜잭션 수신자가 지정된다. to 필드는 20바이트 이더리움 주소를 포함하는데, 이때 주의할 점은 **이더리움은 to 필드를 검증하지 않는다**. 이더리움은 모든 20바이트 값은 유효한 것으로 간주한다.

따라서, 트랜잭션을 잘못된 주소로 보내면, 대부분 대응되는 개인키를 알 수 없기에 다시 사용할 수 없는 상태가 된다. 이렇게 잘못 보내진 이더는 영원히 소실된 것으로 간주되며, 연소되었다고 표현한다.



### EOA 및 컨트랙트로의 트랜잭션

우선 트랜잭션의 주요 '페이로드'는 값과 데이터 2개 필드에 포함된다. 트랜잭션은 값과 데이터의 4가지 조합을 모두 유효하게 여긴다. 각각의 조합이 가지는 의미는 다음과 같다.

1. 값만 존재 : **지급(payment)**
2. 데이터만 존재 : **호출(invocation)**
3. 값과 데이터 모두 존재 : **지급과 호출**
4. 값과 데이터 모두 미존재 : 가스 낭비...



#### EOA 및 컨트랙트로의 지급

목적지 주소(to)가 EOA 주소의 경우, 주소 잔액에 보낸 값을 추가한다.  이전에 주소가 표시되지 않은 경우, 잔액이 지급 금액으로 초기화된다.

목적지 주소(to)가 컨트랙트일 경우, 트랜잭션의 데이터 페이로드에서 지정된 함수를 호출하려고 한다. 데이터가 없으면 **폴백(fallback)** 함수를 호출하게 되며, 폴백 함수 또한 없을 경우, EOA의 경우와 마찬가지로 컨트랙트의 잔액을 늘린다.



#### EOA 및 컨트랙트로의 호출

목적지 주소(to)가 EOA 주소의 경우, 데이터 해석은 사용하는 지갑에 달려 있다. 다만, 대부분의 지갑은 자신이 제어하는 EOA에 대한 트랜잭션에서 수신된 모든 데이터를 무시한다.

목적지 주소(to)가 컨트랙트일 경우, 데이터는 EVM에 의해 **컨트랙트 호출**로 해석된다. 데이터를 함수 호출로 사용하며, 명명된 함수를 호출하고 인코딩된 인수를 함수에 전달한다. ABI 호환 컨트랙트(모든 컨트랙트)로 전송된 데이터 페이로드는 함수 선택기와 함수 인수를 16진수로 시리얼라이즈한 인코딩 정보이다.



:bulb: **특별 트랜잭션 : 제로 어드레스로의 호출**

제로 어드레스라고 하는 특수 대상 주소로 전송할 경우, 새로운 컨트랙트를 생성함. 이때는 컨트랙트를 생성할 컴파일된 바이트코드를 포함하는 데이터 페이로드만 포함하면 됨



### 트랜잭션 전파

우선, 이더리움 클라이언트는 **메시**(mesh) 네트워크를 형성하는 **피어투피어(P2P)** 네트워크에서 **노드(node)**역할을 수행한다. 노드들은 **이웃**이라 부르는 다른 노드들에 대해서 연결을 유지하고 있는데, 평균적으로 13개의 이웃을 가지고 있다. 

트랜잭션은 다음과 같은 과정으로 전파된다. 

1. 트랜잭션을 생성한 노드는 직접 연결된 이웃에게 트랜잭션을 전송한다.
2. 각 이웃 노드는 트랜잭션을 수신하자마자 즉시 유효성을 검사한다.
3. 타당하다는 것에 동의하면, 사본을 저장하고 이웃에 전파한다.
4. 모든 노드가 트랜잭션 사본을 가질 때까지 원래 노드에서 바깥쪽으로 물결치며 퍼진다.



이러한 전파의 특징으로는 각 노드는 트랜잭션의 출처를 식별할 수 없다. 수신 받은 노드는 해당 트랜잭션이 송신한 노드에서 생성된 것인지, 생성자의 이웃으로부터 온 것인지 알지 못 한다. 이것은 P2P 네트워크 보안 및 정보 보호 설계의 일부로, 공격자의 추적을 어렵게 한다.



## 트랜잭션 논스



논스란, 해당 주소에서 보낸 **트랜잭션 건수** 또는 연결된 코드가 있는 계정의 경우 **컨트랙트 생성 건수**와 동일한 스칼라 값이다. 논스는 발신 주소의 속성으로 발신 주소의 컨텍스트 안에서만 의미를 가진다.



### 논스 중요성

논스는 트랜잭션에서 다음 2가지의 중요한 역할을 수행한다. 

첫 번째로, **트랜잭션의 순서를 보장**한다. 이더리움과 같은 탈중앙화된 시스템에서 노드는 어떤 순서로든 트랜잭션을 수신할 수 있다. 하지만 논스는 트랜잭션의 생성 순서대로 결정되기에, 논스를 포함한 상태에서는 노드들이 트랜잭션을 생성된 순서대로 처리할 수 있다. 

두 번째로 **트랜잭션의 복제를 방지**한다. 이더리움 네트워크에서 트랜잭션을 보는 사람은 원래 트랜잭션을 복사하여 붙여넣고 네트워크로 다시 보내는 방식으로 계속 트랜잭션을 반복해서 재실행 가능하다. 논스 값을 사용하면 **각각의 개별 트랜잭션은 고유**해지기에, 재실행을 막을 수 있다.



### 논스 추적

실질적으로 논스는 각 계정에서 발생한 확인 트랜잭션 건수에 대한 최신 통계이다. 따라서, 논스 값을 알기 위해서는 web3 라이브러리의 `getTransactionCount`를 통해서 알 수 있다.

```bash
web3.eth.getTransactionCount("계정주소")
```

하지만, 해당 `getTransactionCount`결과는 미해결 트랜잭션이 모두 확인된 경우에만 신뢰할 수 있다. 새 트랜잭션을 만들 때 시퀀스상 다음 차례 논스 값 부여하는데, 컨펌될 때까지는 `getTransactionCount` 합계에 포함되지 않는다. 예를 들어, 연속해서 몇 개의 트랜잭션을 보내는 경우, 트랜잭션이 모두 정상 처리되기 전까지는 `getTransactionCount`결과에 반영이 안 된다. 



패리티(Parity)의 JSON RPC 인터페이스는 `parity_nextNonce` 함수를 제공하는데, 이는 각각의 트랜잭션을 빠르게 연속적으로 만들더라도 논스를 올바르게 계산한다.



### 논스의 간격, 중복 논스 및 확인

이더리움 네트워크는 논스에 따라 트랜잭션을 순차적으로 처리한다. 모든 노드는 누락된 논스가 단순히 지연되었고, 순서가 맞지 않게 수신되었다고 가정한다. 순서에 맞지 않은 트랜잭션이 먼저 도착한다면, 누락된 논스가 나타날 때까지 트랜잭션은 **멤풀**(mempool)에 저장되어 기다려진다. 

유효하지 않거나 가스가 모자란 트랜잭션은 논스 시퀀스에 의도치 않게 '갭'을 만들 수 있다. 다시 트랜잭션을 계속되게 하려면 누락된 논스가 있는 유효한 트랜잭션을 전송해야 하는데, 이때 모든 브로드캐스트된 트랜잭션이 차례대로 유효해진다는 점도 똑같이 염두하여야 한다.(트랜잭션을 회수하는 것은 불가능하다!)





## 가스



### 개요

가스는 이더리움의 연료로, 이더에 대한 자체 환율을 가진 별도의 가상 화폐이다. 이더리움은 가스를 사용하여 트랜잭션이 사용할 수 있는 자원의 양을 제어한다.

가스는 이더와 분리되어 있는데, 1.이더 가치의 급격한 변화와 함께 발생할 수 있는 변동성으로부터 시스템을 보호하고 2.가스가 지급하는 다양한 자원의 비용 사이의 중요하고 민감한 비율을 관리하기 위함이다.



### gasPrice

`gasPrice` 필드는 트랜잭션 생성자가 가스와 교환하여 지급할 가격을 설정할 수 있게 한다. 가격은 가스 당 웨이 단위로 측정된다. 

지갑은 신속한 트랜잭션 컨펌을 위해 gasPrice를 조정할 수 있다. gasPrice가 높을수록 트랜잭션이 더 빨리 컨펌될 것이며, 우선순위가 낮은 트랜잭션은 낮은 가격을 설정해서 컨펌이 느려지게 할 수 있다. 또한 최소 gasPrice는 0으로, 영원히 컨펌되지 않을 수도 있지만, 블록 공간에 대한 수요가 낮은 기간에는 수수료가 0인 트랜잭션들도 포함되기도 한다.



### gasLimit

gasLimit은 트랜잭션을 완료하기 위해 트랜잭션을 시도하는 사람이 기꺼이 구매할 수 있는 최대 가스 단위 수이다. 실제로 트랜잭션을 수행하는데 설정한 gasLimit보다 더 많은 gas가 필요하게 된다면, 해당 트랜잭션은 fail 처리되고 EVM에 의해 되돌려진다.



### gas비 청구

gas비는 트랜잭션이 완료될 때까지 여러분의 계좌에서 금액이 실제로 차감되지 않는다. 목적지 주소가 컨트랙트인 경우, 필요한 가스양을 추정할 수는 있지만 정확하게 결정할 수는 없다. 이에, 트랜잭션 첫 번째 유효성 확인 단계 중 하나는 계정이 `가스 가격 * 가스 요금`을 지급할 만큼 충분한 이더를 갖고 있는지 확인하는 것이다. 유효하다면, 실제로 소비된 가스의 요금만 청구된다.





## 서명



### 디지털 서명

이더리움에서 사용되는 디지털 서명 알고리즘은 ECDSA로, 4장 암호화에서 살펴보았듯이 개인키-공개키 쌍을 기반으로 한다.  디지털 서명은 3가지 용도로 사용된다.

첫 번째는 **인증**이다. 서명은 이더리움 계정과 개인키의 소유자가 이더 지출 또는 컨트랙트 이행을 **승인**했음을 증명한다.

두 번째는 **부인 방지**(non-repudiation)이다. 즉, 허가의 증거는 부인할 수 없다.

세 번째는 **무결성**(integrity)이다. 서명은 트랜잭션이 서명된 후에는 트랜잭션 데이터가 수정되지 않았고, 트랜잭션 데이터를 **수정할 수 없음**을 증명한다. 



### 디지털 서명 작동 방법

디지털 서명은 두 단계로 구성된 수학적 체계다. 첫 번째 부분은 메시지(트랜잭션)에서 개인키를 사용하여 서명을 만드는 알고리즘이며, 두 번째 부분은 누구나 메시지와 공개키만 사용하여 서명을 검증할 수 있게 해주는 알고리즘이다. 



#### 서명 알고리즘

우선, 디지털 서명은 다음과 같은 수식으로 이루어진다.
$$
Sig = F_{sig}(F_{keccak256}(m),k)
$$

- `k` : 개인키
- `m` : 인코딩된 트랜잭션
- `F_keccak256` : Keccak-256 해시 함수
- `F_sig` : 서명 알고리즘

- `Sig` : 결과 서명



이더리움에서 트랜잭션을 발생하기 위해서는 디저털 서명을 해야 하며, 다음 과정을 거쳐야 한다.

1. nonce, gasPrice, gasLimit, to, value, data, chainID, 0, 0의 9개 필드를 포함하는 트랜잭션 데이터 구조를 만든다

2. RLP로 인코딩된 트랜잭션 데이터 구조의 시리얼라이즈된 메시지를 생성한다.

3. 시리얼라이즈된 메시지의 Keccak-256 해시를 계산한다.

4. 원래 EOA의 개인키로 해시에 서명하여 ECDSA 서명을 계산한다.

5. ECDSA 서명의 계산된 v,r,s 값을 트랜잭션에 추가한다.



#### 검증 알고리즘

서명 검증 알고리즘은 메시지(트랜잭션), 공개키, 서명(r 및 s값)을 가져와서 서명이 메시지와 공개키에 유효하면 true를 반환한다. 



### 서명 및 전송 분리(오프라인 서명)

오프라인 서명이란, 서명 및 전송 기능을 분리하여 다른 시스템에서 수행하는 것을 말한다. 서명과 전송을 분리하는 이유로는 보안 때문이다. 서명하는 컴퓨터에는 잠금 해제된 개인키가 메모리에 로드되어 있어야 한다. 전송을 수행하는 컴퓨터는 인터넷에 연결되어 있으며, 이더리움 클라이언트를 실행해야 한다. 두 기능이 하나의 컴퓨터에 있으면, 온라인 시스템에 개인키가 있게 되어 보안 위험이 발생할 수 있다. 따라서, 다음과 같이 이더리움 트랜잭션의 오프라인 서명 프로세스를 따르는 것이 안전하다.

1. 서명되지 않은 트랜잭션을 온라인 컴퓨터에서 생성

2. 서명되지 않은 트랜잭션을 QR 코드 또는 USB 플래시 드라이브를 통해 서명을 위한 '에어 갭' 오프라인 장치로 전송

3. 서명된 트랜잭션을 QR 코드 또는 USB 플래시 드라이브를 통해 온라인 장치로 전송

