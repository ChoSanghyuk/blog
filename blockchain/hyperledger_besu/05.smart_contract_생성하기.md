

# [Hyperledge Besu] Clique Private Network에서 스마트 컨트랙트 생성하기



이번에는 생성한 Private Network에서 스마트 컨트랙트를 생성해보겠다. 

스마트 컨트랙트는 solidity로 작성된 소스 코드를 컴파일된 바이트코드로 전환하여 제로 어드레스에 보냄으로써 생성할 수 있다.





## 사전 준비



### solidity 설치

solidity 코드를 컴파일하기 위해, npm에 solidicy를 설치하겠다.

이때 주의할 점은 **besu 버전에 따라 지원 가능한 solidity 버전이 존재**한다. 현재 besu 버전인 24.1.1까지는 solidity 0.8.19까지의 버전만 지원 가능하며, solidity 버전이 더 높아질 경우에는 트랜잭션 전송 시 에러가 발생한다.

```bash
npm install solc@0.8.19
```



### 기타 dependency 설치

`js` 코드를 실행할 때, 사용할 library들을 설치해준다.

- `npm install fs-extra`	

- `npm install fs`



## 코드 작성



### 스마트 컨트랙트 코드 작성

스마트 컨트랙트로 등록하고자 하는 기능을 solidity로 작성해야 한다.

이 글에서는 solidity에 대한 내용은 별도로 정리하지 않고, Ethereum IDE인 [Remix](https://remix.ethereum.org/)에서 제공해주는 샘플 코드를 사용하겠다.

#### Storage.sol

```solidity
// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.1 <0.9.0;

/**
 * @title Storage
 * @dev Store & retrieve value in a variable
 * @custom:dev-run-script ./scripts/deploy_with_ethers.ts
 */
contract Storage {

    uint256 number;

    /**
     * @dev Store value in variable
     * @param num value to store
     */
    function store(uint256 num) public {
        number = num;
    }

    /**
     * @dev Return value 
     * @return value of 'number'
     */
    function retrieve() public view returns (uint256){
        return number;
    }
}
```

:bulb: solidity는 파일 상단의 `pragma`를 통해서 compiler 버전을 명시한다. 따라서, 설치된 solidity 버전과 pragma 부분을 맞춰야 정상적으로 compile 가능하다.



### compile 수행 코드 작성

`Storage.sol` 부분을 컴파일하여, 결과를 `Storage.json` 파일로 저장한다.

#### compile.js

```javascript
const fs = require("fs").promises;
const solc = require("solc");

async function main() {
  // Load the contract source code
  const sourceCode = await fs.readFile("Storage.sol", "utf8");
  // Compile the source code and retrieve the ABI and bytecode
  const { abi, bytecode } = compile(sourceCode, "Storage");
  // Store the ABI and bytecode into a JSON file
  const artifact = JSON.stringify({ abi, bytecode }, null, 2);
  await fs.writeFile("Storage.json", artifact);
}

function compile(sourceCode, contractName) {
  // Create the Solidity Compiler Standard Input and Output JSON
  const input = {
    language: "Solidity",
    sources: { main: { content: sourceCode } },
    settings: { outputSelection: { "*": { "*": ["abi", "evm.bytecode"] } } },
  };
  // Parse the compiler output to retrieve the ABI and bytecode
  const output = solc.compile(JSON.stringify(input));
  const artifact = JSON.parse(output).contracts.main[contractName];
  return {
    abi: artifact.abi,
    bytecode: artifact.evm.bytecode.object,
  };
}

main().then(() => process.exit(0));
```



### 스마트 컨트랙트 생성 트랜잭션 수행

컴파일된 바이트 코드를 읽어와 스마트 컨트랙트 생성 트랜잭션을 전송하는 코드를 작성한다. 

스마트 컨트랙트 생성 트랜잭션은  지급 트랜잭션에서 두 가지를 다르게 설정해 주어야 한다.

1. `to` field를 `null`로 설정한다.
2.  `data` field를 바이트 코드 값으로 설정한다.

#### contract_create.js

```javascript
const path = require('path');
const fs = require('fs-extra');
const {Web3}  = require('web3');
const { tessera, besu, accounts } = require("./keys.js");

// host는 signer 중 하나를 선택한다.
const host = besu.member1.url;

// Storage.json로부터 byte 코드를 읽어온다.
const contractJsonPath = path.resolve(__dirname,'Storage.json');
const contractJson = JSON.parse(fs.readFileSync(contractJsonPath));
const contractBytecode = contractJson.bytecode 


async function createContract(host) {
  const web3 = new Web3(host);
  const account = accounts.account1 // 트랙잭션 발신 account는 아무 account여도 상관 없다.

  // 1. 발신 EOA가 보내고자 하는 트랜잭션을 작성한다.
  const txn = {
    chainId: 2018, 						// genesis 파일에 명시한 chainId를 기입한다.
    nonce: await web3.eth.getTransactionCount(account.address),     
    from: account.address,
    to: null, 							// 중요! 컨트랙트 생성 트랜잭션은 null값 입력 
    value: null,						// 지급 트랜잭션 외에서는 값 null로 입력
    data: '0x'+contractBytecode,		// 스마트 컨트랙트 바이트 코드 입력
    gasPrice: "0x0",     				// 가스 가격
    gas: "0x2CA51"  					// 가스 한도 
  };

  // 2. 발신 EOA가 자신이 보내고 싶은 트랜잭션에 자신의 private key로 서명을 한다.
  const signedTx = await web3.eth.accounts.signTransaction(txn, account.privateKey);
  console.log("sending the txn")
  // 3. signer는 서명된 트랜잭션을 전파하고 블록에 기입한다.
  const txReceipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
  console.log("txReceipt ", txReceipt)
  return txReceipt;
};

async function main(){
  createContract(host)

}

if (require.main === module) {
  main();
}

module.exports = exports = main

```



