# [마스터링 이더리움] 10장. 토큰



본 포스트는 서적 *마스터링 이더리움*의 10장 *토큰* 파트를 정리한 포스트입니다. 



## 토큰



### 블록체인에서의 토큰

일반적으로 토큰은 사소한 내재가치를 지닌, 사적으로 발행한 특수 용도의 동전 같은 물건을 지칭하기 위해 사용된다. 하지만 블록체인에서는 토큰을 소유할 수 있고, 자산, 화폐 혹은 접근 권한 등 블록체인 기반의 추상화된 의미로 재정의한다. 블록체인 토큰은 다양한 용도로 사용되며, 서로 교환되거나 거래 가능하다. 또한 사용과 소유에 대한 제한이 없어지면서, 내재 가치에 대한 한계가 없어진다. 



### 용도

토큰은 다음과 같은 용도들로 사용될 수 있다.

- 화폐

- 자원
  - 공유 경제, 자원 공유 환경에서 획득하거나 생산된 자원을 나타낼 수 있음 (ex. 네트워크 상의 스토리지,  CPU )

- 자산
  - 내재적, 외적 혹은 유형, 무형 자산의 소유권

- 접근

- 지분

- 투표
- 수집
  - 디지털 혹은 물리적 수집물

- 신원

- 증명

- 유틸리티
  - 서비스에 대한 접근, 사용료의 지불



블록체인에서 토큰은 여러 기능을 포함할 수도, 아니면 이전에 합쳐진 기능을 분리시켜 독립적으로 개발할 수 있다. 



### 속성

토큰은 **대체성**과 **내재성**이란 속성을 가진다.

대체성은 개별 단위가 본질적으로 서로 호환성을 가지고 있는 재화 상품의 속성을 의미한다. 단일 단위를 값이나 기능의 차이 없이 다른 토큰으로 대체할 수 있는 경우에 대체 가능(fungible)하다고 한다.

이와 반대로, 대체 가능하지 않은 토큰은 고유한 유형 또는 무형의 항목을 나타내는 토큰으로, 상호 교환이 불가능하다. 만약, 토큰의 과거 출처를 추적 관리할 수 있다면 토큰은 완전히 대체 가능 하지 않다. 과거 출처를 추적하는 능력은 블랙리스트 혹은 화이트리스트를 낳을 수 있으며, 대체성을 줄이거나 없앨 수 있다. 



내재성은 어떤 사물이나 성질이 그것들과는 별개의 것 안에 포함돼 있는 것으로, 일부 토큰은 블록체인에 내재적인 디지털 아이템을 나타낸다. 디지털 자산은 합의 규칙에 의해 관리된다.

내재성을 가지는 블록체인 토큰의 중요한 특징 중의 하나로, **내재적 자산을 나타내는 토큰에는 추가적인 거래상대방 위험이 없다.** 거래상대방 위험은 트랜잭션에서 상대방이 자신의 의무를 이행하지 못하는 위험으로, 두 개보다 더 많은 주체들이 개입되어 있는 경우, 추가적인 거래상대방 위험이 존재한다. 하지만 블록체인 내에서 합의 규칙이 적용되고, 개인키의 소유권 가지면 **중개자가 필요 없다**.

특히 블록체인은 외재적 자산을 내재적 자산으로 변환 가능하다. 외재적 자산은 별도의 법률, 관습 및 정책에 의해 관리되며, non-smart 컨트랙트에 의존한다. 이로 인해, 추가적인 거래상대방 위험이 있다. 블록체인은 이를 내재적 자산으로 변환하여 거래상대방 위험을 제거시킨다.



## 이더리움 토큰



### 개요

이더리움에서 토큰은 이더와 완전히 다른 개념이다. 이더는 이더리움 프로토콜 수준에서 처리되며, **토큰은 스마트 컨트랙트 수준에서 처리**된다. 이더리움 프로토콜은 토큰에 대해 아무것도 알지 못 한다. 

새 토큰을 만들려면 새로운 스마트 컨트랙트를 만들어야 한다. 배포된 스마트 컨트랙트는 토큰의 소유권 이전 및 접근 권한을 포함한 모든 것을 처리한다. 담당 스마트 컨트랙트 외에는 해당 토큰에 대한 기능이 없으며, 해당 토큰에 대한 처리 기능이 없는 컨트랙트에 토큰 전송 시, 토큰은 영원히 사라진 것과 동일하다.



### ERC-20 표준

ERC는 이더리움 토큰 표준을 나타낸다. 그 중 ERC-20은 대체 가능한 토큰의 표준으로, 다른 단위가 상호 교환이 가능하고 고유한 특성이 없음을 의미한다.



#### ERC-20 함수 및 이벤트

ERC-20을 준수하는 토큰은 다음의 필수 함수 및 이벤트를 제공해야 한다.

- `totalSupply`
  - 현재 존재하는 이 토큰의 전체 개수를 리턴
- `balanceOf`
  - 해당 주소의 토큰 잔액을 반환
- `transfer`
  - 주소와 금액이 주어지면, 주소로 토큰의 양 전송
- `transferFrom`
  - 보낸 사람, 받는 사람, 금액이 주어지면 한 계정에서 다른 계정으로 토큰 전송
  - `approve`와 조합되어 사용
- `approve`
  - 그 주소가 승인을 한 계정에서 최대 금액까지 여러 번 송금할 수 있도록 승인
- `allowance`
  - 소유자 주소와 지출자 주소가 주어지면, 지출자에게 `approve`된 금액 리턴
- `Transfer`
  - 전송이 성공하면 이벤트가 트리거됨
- `Approval`
  - `approve`가 성공하면 이벤트가 기록



또한, 아래의 함수를 선택적으로 추가할 수 있다.

- `name`
  - 사람이 읽을 수 있는 토큰의 이름 반환
- `symbol`
  - 사람이 읽을 수 있는 기호 반환
- `decimals`
  - 토큰 양을 나눌 수 있는 소수 자릿수 반환



#### ERC-20 데이터 구조

ERC-20은 2개의 데이터 매핑(data mapping)구조를 포함하고 있다. 하나는 잔고를 추적하는 매핑이며, 다른 하나는 허용량을 추적하는 매핑이다. 잔고 추적은 소유자별로 토큰 잔액을 내부 테이블로 구현하며, 허용량 추적은 토큰 소유자가 권한을 위임자에게 위임한 지출 허용량을 추적한다.



#### 전송 워크플로

위의 함수에서 볼 수 있듯이, ERC-20은 두 가지의 토큰 전송 워크플로를 가진다.

첫 번째는 `transfer` 를 사용하는 단일 트랜잭션인 간단한 워크플로이다.  지갑에서 다른 지갑으로 토큰을 보내는데 사용되는 워크플로이다.

두 번째는 `approve`와 `transferFrom`을 사용하는 두 단계 트랜잭션 워크플로이다. `approve`는 토큰 소유자가 자신의 보유 토큰 중에서 일정 금액에 대한 지출 권한을 다른 주소에게 위임하게 해준다. 위임받은 주소는 `transferFrom`를 통해서, approve된 금액 내에서는 무제한으로 토큰을 전송할 수 있다.



#### 문제점

토큰과 이더 자체 사이의 미묘한 차이로 인해서, ERC20 토큰을 다루는 데에 문제점이 발생한다. 우선, 전송 과정에 차이가 있다. 이더는 수신자의 주소를 목적지로 가지고 있는 트랜잭션에 의해 전송되지만, 토큰 전송은 특정한 토큰 컨트랙트 상태 안에서 일어나고 수신자의 주소가 아닌 토큰 컨트랙트를 목적지로 한다. 토큰을 주소로 하는 트랜잭션은 토큰 컨트랙의 상태만 변경하고 수신자 주소의 상태는 변경하지 않는다. 이로 인해, ERC-20 토큰을 지원하는 지갑조차도 사용자가 토큰 컨트랙트를 명시적으로 추가하지 않는 한 토큰 잔액을 인식하지 못 한다.

또한, 토큰 트랜잭션에도 가스를 지급해야 하기에 이더가 필요하다. 트랜잭션의 가스는 토큰으로 지급할 수 없기에 토큰 컨트랙트는 자체적으로 가스를 지급할 수 없다. 이로 인해서, 이더를 토큰으로 정상적으로 교환하였지만, 토큰을 역으로 이더로 교환할 때에는 자체적으로 가스비를 못 내어 트랜잭션을 요청하지 못 하는 경우가 생길 수 있다. 



### 그 외 주요 이더리움 토큰 표준

|      | ERC-223                                     | ERC-721                                                      | ERC-777                                                      | ERC-1155                                                     | ERC-1400                                                     |
| ---- | ------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 개요 | 토큰 컨트랙트 인터페이스 표준               | 고유한 식별자를 갖는 불가분 토큰(Non-Fungible Token, NFT)을 만들기 위한 표준 | 향상된 토큰 표준으로서, 보안과 기능 면에서 향상된 기능을 제공 | 다중 자산을 하나의 스마트 컨트랙트에 발행하는 표준           | 보안 토큰 및 STO(보안 토큰 제의)를 위한 표준                 |
| 목표 | 실수로 토큰을 컨트랙트에 전송하는 문제 해결 | 유일한 NFT 자산을 만들고 관리하는 표준화된 방법 제공         | 토큰 보안성 및 기능성을 향상시키고, 사용자 경험을 개선하는 표준화된 방법 제공 | 단일 스마트 컨트랙트 내에서 다중 자산을 관리하는 표준화된 방법 제공 | 보안 토큰의 발행 및 관리에 필요한 표준화된 방법 제공         |
| 특성 | 목적지 주소가 컨트랙트인지 아닌지 여부 감자 | 각 토큰은 고유한 속성과 식별자를 가지며, 각 토큰은 서로 교환 가능하지 않움 | 토큰을 보유한 주소에게 자동으로 이벤트를 발생시키고, 보안 및 전송 기능을 향상시키는 등의 기능을 포함 | ERC721과 ERC20의 장점을 결합<br />=> 단일 스마트 컨트랙트 내에서 다양한 유형의 토큰을 관리 | 토큰을 발행, 이전, 소유권 확인 및 분할하는 데 필요한 기능을 제공 |
| 한계 | 널리 채택되지 않아 호환성 문제 有           | 토큰이 고유하다는 특성 때문에 대량의 토큰을 다루기에는 비효율적 | 널리 채택되지 않아 호환성 문제 有                            | 각 토큰의 고유성이 없어서 일부 사용 사례에는 적합하지 않을 수 있음 | 안 토큰을 다루기 위한 고급 기능을 제공하지만, 일반적인 토큰 사용 사례에는 복잡함 |



### 토큰 표준 사용

그렇다면 토큰 표준은 사용되어 하는 것일까? 

우선 토큰 표준이란 구현을 위한 **최소** 사양이다. 토큰 표준은 컨트랙트 간의 **상호운용성**을 장려하고, 예측 가능한 방식으로 동작하도록 **인터페이스**를 제공한다. 

이러한 토큰 표준은 **규범적**(prescriptive)이라기보다는 **기술적**(descriptive)인 것을 의도한다. 인터페이스를 구현할지 결정하는 것은 생성자에게 달려 있으며, 내부 기능은 표준과 관련이 없다. 

따라서, **표준 사용의 목적은 상호운용성 및 광범위한 보급이 가지는 가치를 얻는 것**이다. 표준을 따르면, 해당 표준을 사용하도록 설계된 모든 시스템의 가치를 얻게 된다. 표준을 벗어나 모든 인프라를 직접 구축하며 자신의 길을 만들 것인지, 아니면 기존 표준를 따를 것인지에는 신중한 고려가 필요할 것이다.



### 토큰 인터페이스 표준 확장

토큰 표준은 최소한의 인터페이스만을 제공한다고 하였다. 이에, 많은 프로젝트가 애플리케이션에 필요한 기능을 제공하기 위해 확장된 구현을 만들었다. 이중 주된 기능은 다음과 같다. 

- 소유자 제어
- 소각
  - 토큰을 고의로 파괴할 수 있는 주소로 전송하거나 잔액을 지우는 것으로, 의도적으로 토큰을 파괴
- 발행
  - 토큰 총 공급량을 추가하는 기능
- 크라우드펀딩
  - 경매, 시장 판매, 역 경매 등을 통해 판매용 토큰을 제공
- 캡
  - 총 공급량을 미리 정의된 불변의 양으로 제한을 설정
- 복구 백도어
  - 자금을 복구하거나, 송금을 되돌리거나, 지정된 주소 또는 주소의 집합에 의해 활성화 될 수 있는 토큰을 소거
- 화이트리스트
  - 토큰 전송 등의 작업을 특정 주소로 제한
- 블랙리스트
  - 특정 주소를 허용하지 않음으로 토큰 전송을 제한



앞서 설명했듯이, 토큰 표준을 확장하는 데는 혁신/위험과 상호운용성/보안 간의 절충이 필요하다.