# [마스터링 이더리움] 5장. 지갑



본 포스트는 서적 *마스터링 이더리움*의 5장 *지갑* 파트를 정리한 포스트입니다. 



지갑이란, 넓은 의미로는 이더리움의 주요 사용자 인터페이스를 제공하는 소프트웨어 애플리케이션을 의미한다. 개발자의 시각으로 좁혀보면, 사용자의 키를 보관하고 관리하기 위해 사용되는 시스템을 의미하며, 모든 지갑은 키 관리 구성요소를 가지고 있다.

지갑에 대한 일반적인 오해는 지갑이 이더 혹은 토큰을 직접 보유한다는 것이다. 하지만 실제로 지갑은 단지 키만 보유하며, 이더와 토큰은 이더리움 블록체인에 기록된다. 이러한 맥락에서 이더리움 지갑은 개인키와 공개키 쌍을 포함하는 키체인과 같다.

이번 장에서는 개인키를 담는 공간이자 키를 관리하는 시스템으로서 지갑을 살펴볼 것이다.



## 지갑 기술 개요



지갑을 설계 할 때 중요한 고려사항 중 하나로는 편의성과 프라이버시 사이의 균형을 맞추는 것이다. 극단적인 편의성을 추구하면, 하나의 개인키와 주소를 가지고 이를 재사용해서 모든 것을 처리하는 방안이 있을 것이다. 하지만 이는 프라이버시에 대한 악몽이 생길 가능성이 있다. 이와 반대로, 극단적인 프라이버시를 추구하면, 모든 트랜잭션에 새로운 키를 사용하는 하는 방안이 된다. 하지만 이는 키와 주소를 관리하는기가 몹시 어려울 것이다. 



## 지갑 유형

지갑에는 두 가지 유형이 있다.



### 비결정적 지갑

첫 번째는 **비결정적 지갑**이다. 비결정적 지갑은 **각기 다른 무작위 수로부터 각각의 키를 무작위적으로 추출**하는 방식의 지갑이다. 이더리움 주소의 재사용을 피하는 것이 좋은 지침으로 간주되기에, 자금을 받을 때마다 새로운 주소(새로운 개인키가 필요)를 사용하는 것이 권장된다. 비결정적 지갑에서 이를 따르기 위해서는 정기적으로 키 목록을 증가시켜야 하는데, 이는 정기적인 백업이 필요하다는 의미와 상동한다. 

비결정적 지갑은 백업 전 데이터를 잃어버리면 해당 계정의 자금과 스마트 컨트랙트에 접근할 수 없게 된다. 특히, 비결정적 지갑은 때마다 새로운 지갑 파일을 생성하기에 다루기 매우 어렵다. 따라서, 간단한 테스트 외에는 비결정적 지갑은 사용 권장되지 않는다.



### 결정적 지갑

두번째는 **결정적 지갑**이다. 결정적 지갑은 **모든 키가 시드(seed)라고 하는 단일 마스터 키로부터 파생**되는 방식의 지갑이다. 모든 키는 서로 관련이 있고, 원래의 시드를 갖고 있다면 다시 키를 파생시킬 수 있다. 새로운 키가 필요한 경우네는 파생 키들을 사용하면 되며, 파생 키에 대해 백업이 안 되어 있더라도 시드만 백업해두었다면 다시 키를 찾을 수가 있기에 비결정적 지갑에 비해 다루기가 쉽다. 결정적 지갑에는 여러 개의 표준이 존재하며, 이에 대해서 자세히 알아보겠다.





## 결정적 지갑 표준



### BIP-32 : HD 지갑

우선 BIP는 Bitcoin Improvement Proposal의 약자로, BIP-32는 HD 지갑(Hierarchical Deterministic Wallet)에 대한 표준을 제공한다.

HD 지갑은  BIP-32 표준으로 정의된 결정적 지갑으로 트리 구조로 파생된 키들을 가지고 있다. HD는 다른 결정적 지갑에 비해 두가지 장점을 가진다. 첫 번째로 트리 구조를 가진다. 파생 키들을 분기별로 다른 용도 지정이 가능하여, 구조적인 의미를 표현할 수 있다. 두 번째로, 개인키에 접속하지 않고 사용자가 공개키 시퀀스 생성이 가능하다. HD 지갑은 보안상 안전하지 않는 서버, 보기 전용, 수신 전용의 용도로 사용 가능하다. 이때 이 지갑에는 자금을 움직이는 개인키가 들어 있지 않게 가능하다.

![image-20240224162619109](img/image-20240224162619109.png)

[그림 5-1 HD 지갑 : 단일 시드로부터 생성된 키 트리] ([출처 : steemit](https://steemit.com/busy/@etainclub/2d76k2-5))



위의 그림처럼, 키는 확장(extended)될 수 있다. 적절한 수학적 연산을 사용하여 확장된 부모키는 자식키를 파생시킬 수 있게 되고, 키와 주소의 계층 구조를 만들 수 있게 된다. 

키를 확장하는 것은 키 자체를 가져와서 특수 **체인 코드**를 추가하는 것이다. 





 When you use a BIP-32 compatible library or tool to derive child private keys from your master private key, the resulting extended private keys (often referred to as child extended private keys) will typically start with the "xprv" prefix. This prefix indicates that the key is an extended private key capable of generating child keys. The library or tool follows the BIP-32 algorithm to perform the derivation process, ensuring that the resulting keys are properly formatted and secure for use within a hierarchical deterministic wallet. Therefore, you can expect the derived extended private keys to adhere to the "xprv" prefix convention.



While the master private key (the root of the hierarchy) does start with "xprv", the child keys derived from it do not necessarily start with "xprv".





The chain code plays a crucial role in the key extension process within the BIP-32 (Bitcoin Improvement Proposal 32) specification. When deriving child keys from a parent key, both the child private key and the chain code are computed together.

The chain code serves two main purposes:

1. **Deterministic Generation of Child Keys:**
   - The chain code ensures that child keys are generated deterministically from their parent key. This means that for a given parent key, the resulting chain code is unique and consistent across different implementations of BIP-32-compatible wallets. This deterministic property is essential for ensuring that the same wallet can be recreated from a single master key.
2. **Security and Privacy:**
   - The chain code enhances the security and privacy of the key derivation process. By combining the chain code with the parent key, the resulting child keys are cryptographically linked to their parent. This linkage prevents someone who knows one child key from easily determining other child keys in the hierarchy without access to the parent key and chain code. It provides a level of protection against certain types of attacks, even if some child keys are compromised.

In summary, the chain code ensures deterministic generation of child keys and enhances the security and privacy of the key derivation process within the BIP-32 framework. It is a critical component in hierarchical deterministic wallets, allowing for the creation of a tree-like structure of keys derived from a single master key.







https://iancoleman.io/bip39/











