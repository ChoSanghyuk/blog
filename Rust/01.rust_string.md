# [Rust] 문자열



문자열은 메모리의 동적 할당 및 재할당이 빈번하게 일어나는 타입 중의 하나이다. Rust에서는 이러한 문자열을 효율적으로 다루기 위해 여러 개의 문자열 타입을 제공하는 데, 그 중  `String`과 `&String`, `&str` 타입이 가장 보편적으로 사용된다. 

Rust의 문자열 타입을 효율적으로 사용하기 위해, Rust에서 String의 동작 구조에 대해 배우고, `String`과 `&String`, `&str`  타입 간 비교를 해보고자 한다.



## 문자열 동작 방식

우선, Rust에서 String이 어떻게 메모리를 배정받고, 또 어떻게 문자열을 저장하는지 알아보겠다.



### Memory Allocation

Memory Allocation이란, 컴퓨터에서 실제 값을 저장하기 위해 메모리 블록을 설정하는 것이다. Runtime 시에 선언되는 문자열의 경우 heap 영역에서 메모리를 할당받아서 사용하게 된다.

문자열의 경우, 할당받은 메모리 크기의 재조정이 가능하다. 왜냐하면 String은 여타 primitive 타입과 다르게 필요한 메모리 크기가 고정되어 있지 않다. 선언 당시의 문자열에서 점점 문자열의 길이가 길어진다면 더 큰 크기의 메모리 공간으로 재배정을 받게 된다.



예를 들어, 다음과 같이 문자열의 길이를 점점 늘리는 코드가 있다면, 문자열이 배정받은 메모리의 크기는 점점 늘어나게 된다.

```rust
let mut s = String::new();

println!("{}", s.capacity());

for _ in 0..5 {
    s.push_str("hello");
    println!("{}", s.capacity());
}
```

```rust
// 결과
0
8
16
16
32
32
```

:bulb: 길이가 늘어나도 배정받은 메모리 영역 안에 저장할 수 있다면 재배정이 일어나지 않는다.



하지만, 메모리 배정은 컴퓨터 자원 소모의 측면에서 **비싼(expensive) 작업**에 속한다. 

그렇기 때문에 **꼭 필요한 상황이 아니라면, 메모리 배정이 일어나지 않도록 문자열을 참조받아 처리**하는 것이 효율적이다.



혹은 문자열이 수정이 될 예정이라면, 처음부터 큰 메모리를 부여하는 방법도 있다.

String 타입의 `pub fn with_capacity(capacity: usize) -> [String]`  메소드는 해당 문자열에 초기 할당될 메모리 크기를 설정해준다.

```rust
let mut s = String::with_capacity(25);

println!("{}", s.capacity());

for _ in 0..5 {
    s.push_str("hello");
    println!("{}", s.capacity());
}
```

```rust
// 결과
25
25
25
25
25
25
```

예제처럼 문자열 수정이 해당 capacity 이하로 진행된다면 재할당은 일어나지 않으며, capacity를 상회하는 문자열 수정이 있을 때 다시 재조정이 이루어진다.





### 문자열 저장 형식



Rust의 모든 문자열 타입은 유효한 UTF-8(valid UTF-8) 타입으로 저장된다. 



:bulb: Unicode vs UTF-8

- Unicode는 **character set**으로, 각각의 단어를 십진수 형태로 표현한다. 예를 들어, A는 65, B는 66과 같은 방식으로 저장한다.
- UTF-8은 **encoding**으로, unicode를 읽어서 어떻게 컴퓨터가 읽을 수 있는 이진수로 변환할지에 대한 방식이다. 







One thing all string types in Rust have in common is that they’re always guaranteed to be valid UTF-8.



String과 str은 공통적으로 UTF-8 형태로 저장이 된다.

이 둘 문자열을 구성하는 배열은 char로 이루어진 것이 아닌  Unicode 코드로 이루어지게 된다.

이로 인해서, 문자열의 크기는 같은 char 형태의 배열보다 크기가 작거나 같으며, s[i]와 같은 인덱싱이 불가능하다.



### ASC2 코드로 문자열 생성

```rust
let s1 = "hello"; // [104, 101, 108, 108, 111]
assert_eq!(s.len(), 5);

let s2 = ['h', 'e', 'l', 'l', 'o'];
assert_eq!(size, 20);
```

예를 들어 다음과 같이 "hello"라는 값으로 문자열을 생성하게 된다면, rust는 자동적으로 해당 값을 asc2코드로 저장하게 되며 요소 하나당 1Byte를 가지게 된다.

이에 반해,  "hello"를 char의 배열로 저장하게 된다면, 하나의 char은 4byte를 크기를 가지기 때문에 asc2 코드로 저장하는 것보다 memory를 많이 차지하게 된다.



### ASC2 코드가 지원하지 않는 문자열 생성

```rust
let s1 = "안녕"; // [236, 149, 136, 235, 133, 149]
assert_eq!(s.len(), 6)

let s2 = ['안', '녕'];
assert_eq!(size, 8);
```

만약, ASC2가 아닌 값을 문자열로 생성하게 된다면, Unicode는 한 글자당 2~4 byte를 소모하여 저장하게 된다. 



위의 경우들 처럼, Rust에서 문자열은 단순히 char 형식이 아닌 코드값들로 저장한다. 이로인해,  s1[0]과 같은 slice indexing이 가능하더라도 236이라는 우리가 원하는 결과 값을 얻지 못 한다. 

결과적으론 Rust는 문자열의 경우 항상 valid UTF-8  형식을 지원하기 때문에, s1[0] 를 사용하고 싶더라도 Rust에서 컴파일 에러를 이르켜 실행할 수 없다.



### 문자열 인덱싱

문자열을 인덱싱하고 싶을 때에는 다음 두가지 방법으로 가능하다

- s1.chars().nth(i).unwrap()

​	첫번째로는 unicode byte로 구성된 문자열 s1을 char 형태로 변환하여 인덱싱하는 것이다.

​	Rust는 char또한 Unicode로 지원하기 때문에, 해당 방식을 통해 인덱싱이 가능해진다.

​	여기 .chars().nth(i)를 수행한 결과 값은 Option 을 반환하기 때문에 값을 얻기 위해서는 unwrap()을 수행해야 한다.

- std::str::from_utf8(&s1.as_bytes()[i..j]).unwrap()

​	두번째로는 Unicode Byte 배열을 직접 슬라이스하여 UTF-8로 변환하는 것이다.  

​	이를 위해서는 문자열 s1에 들어있는 값들이 몇 byte 를 기준으로 하나의 Unicode로 변환될지를 알고 있어야 한다.

```rust
fn main() {

    let s1 = "안녕";
    let utf_str1 = std::str::from_utf8(&s1.as_bytes()[0..3]).unwrap();
    let utf_str2 = std::str::from_utf8(&s1.as_bytes()[3..6]).unwrap();
    
    println!("{}", utf_str1); // 안
    println!("{}", utf_str2); // 녕

}
```

​	위 처럼, 한국어의 경우에는 3byte를 단위로 Unicode로 전환되기 때문에 s1의 byte 배열을 3개씩 묶어서 변환한다면 우리가 원하는 자소(grapheme) 단위의 indexing이 가능해진다. 사전에 해당 문자열의 byte 단위를 알고 있어야 한다는 제약이 있지만, 빠르고, 일정한 수행 시간 (constant-time operation)이 가능하다는 장점이 있다.













## `String` vs `&String` vs `&str`

우선, `String`은 **owned type**으로써, 자신의 값을 저장하는 메모리를 소유한다. 메모리는 heap 영역에 배정되며, 크기가 재조정하다는 특징이 있다. String은 **pointer**, **len**, **capcity**를 가지고 있다. pointer은 heap에 저장된 값에 대한 pointer이며, len은 해당 문자열의 길이, capacity는 배정된 메모리의 크기이다.

`&String`은 단순히 `String`에 대한 참조이다. 즉 owned type이 아니며, 실제 `String`에 대한 pointer에 불과하기에 고정된 메모리 크기를 컴파일 시점에 알 수 있다. 만약 참조하는 `String`이 `mut` 타입인 경우, `mut &String` 타입으로는 **실제 값에 접근하여 값을 조작하는 것이 가능**하다.

`&str`은 String 조각에 대한 **읽기전용 참조**이다. `&String`과 마찬가지로 단순 pointer에 불과하기에, owned type이 아니며 고정된 메모리 크기를 컴파일 시점에 알 수 있다. `&str`은 메모리의 배정이 필요 없기 때문에 **pointer**와 **len**으로만 구성된다. `&str`은 **실제 값에 접근하여 값을 조작하는 것이 불가능**하며, rust는 스코프 안에 `&str`이 있는 동안, **참조하는 메모리가 변하지 않음을 보장**한다. (심지어 thread간에도)



## 타입간 활용의 차이



각 타입간 ownership과 memory allocation에 있어서 차이가 존재

&str로 값을 받아서 처리하는 것이 효율적이다. (&str로의 conversion은 inexpensive)



An interesting aspect of `&String` is that it can be deref-coerced to `&str` by the Rust compiler. This is great in terms of API flexibility. However, this does not work the other way around:





&str은 &String을 대신하여 변수를 받을 수 있다 (&String can be deref-coerced to &str). 

함수의 인자값으로 받는 문자열을 받을 때, 소유권과 수정이 필요 없다면, 유용하게 사용될 수 있다. (역으로, 소유권과 수정이 필요없게끔 강제할 수 있다)

As mentioned above, `&String` can be coerced to `&str`, which makes `&str` a great candidate for function arguments, if mutability and ownership are not required.

Its best used when a slice (view) of a string is needed, which does not need to be changed



This is important to know, but as mentioned above, the memory the `&str` points to can not be changed while the `&str` is in existence, even by the owner of the `str`.



Consider a case where within a nested loop, 





## 차이점 : ownership과 memory







### &str의 String 참조









해당 글은 다음의 자료들을 참조, 번역하여 작성되었습니다.

- Rust, Struct std::string::String, https://doc.rust-lang.org/std/string/struct.String.html
- LogRocket, Understanding String and &str in Rust, https://blog.logrocket.com/understanding-rust-string-str/

- Udemy, Ultimate Rust Crach Course, Nathan Stocks